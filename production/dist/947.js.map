{"version":3,"file":"947.js","mappings":"4PA2BA,QAZiB,SAAIA,GACnB,I,IAA+CC,G,GAArBC,EAAAA,EAAAA,UAASF,G,EAAY,E,k5BAAxCG,EAAKF,EAAA,GAAEG,EAAQH,EAAA,GAQtB,MAAO,CAACE,GANQE,EAAAA,EAAAA,cAAY,SAACC,GAG3BF,EAASE,EAAEC,OAAOJ,MACpB,GAAG,IAEqBC,EAC1B,C,iHClBaI,GAAMC,EAAAA,EAAAA,GAAA,UAAAF,OAAA,YAAAE,CAAA,CAAAC,KAAA,SAAAC,OAAA,sQAiBNC,GAAIH,EAAAA,EAAAA,GAAA,QAAAF,OAAA,YAAAE,CAAA,CAAAC,KAAA,UAAAC,OAAA,8CAMJE,GAAKJ,EAAAA,EAAAA,GAAA,SAAAF,OAAA,YAAAE,CAAA,CAAAC,KAAA,UAAAC,OAAA,sJAcLG,GAAKL,EAAAA,EAAAA,GAAA,SAAAF,OAAA,YAAAE,CAAA,CAAAC,KAAA,SAAAC,OAAA,ikBAyBLI,GAAMN,EAAAA,EAAAA,GAAA,UAAAF,OAAA,YAAAE,CAAA,CAAAC,KAAA,UAAAC,OAAA,6eAkCNK,GAAKP,EAAAA,EAAAA,GAAA,OAAAF,OAAA,YAAAE,CAAA,CAAAC,KAAA,UAAAC,OAAA,qDAMLM,GAAOR,EAAAA,EAAAA,GAAA,OAAAF,OAAA,YAAAE,CAAA,CAAAC,KAAA,UAAAC,OAAA,mCAKPO,GAAaT,EAAAA,EAAAA,GAAA,KAAAF,OAAA,YAAAE,CAAA,CAAAC,KAAA,SAAAC,OAAA,0K,0DCtF1B,QAhBgB,SAACQ,GAAW,OAAKC,IAAAA,IAAUD,EAAK,CAAEE,iBAAiB,IAAQC,MAAK,SAACC,GAAQ,OAAKA,EAASC,IAAI,GAAC,C","sources":["webpack://sleact-ts-front/./hooks/useInput.ts","webpack://sleact-ts-front/./pages/SignUp/style.tsx","webpack://sleact-ts-front/./utils/fetcher.ts"],"sourcesContent":["// custom hook이 특별한 것이 아님!\n// React에서 제공하는 hook을 하나로 합쳐 새로운 hook을 만드는 것\nimport { ChangeEvent, Dispatch, SetStateAction, useCallback, useState } from 'react';\n\n// ts\n// 1. 변수, return type은 추론을 잘 하는데 매개 변수는 잘 하지 못함 => 매개 변수는 대부분 type을 명시해야 함\n// - 여러 타입이 들어올 수 있기 때문에, 특정할 수 없는 경우\n// - 1) any\n// - 2) generic : T로 정의한 타입 매개 변수를 함수 내에서 그대로 사용할 수 있음\n// 2. 가독성이 좋지 않아지는 경우가 많음\n// - type 키워드를 이용해 변수화가 가능!\n\ntype useInpuReturnType<T> = [T, (e: ChangeEvent<HTMLInputElement>) => void, Dispatch<SetStateAction<T>>];\n\n// extends를 사용하여 타입을 최소한의 명시가 가능\nconst useInput = <T>(initialData: T): useInpuReturnType<T> => {\n  const [value, setValue] = useState(initialData);\n\n  const handler = useCallback((e) => {\n    // type을 강제로 바꾸는 방법\n    // any를 사용하는 것만큼이나 좋지는 않음\n    setValue(e.target.value as unknown as T);\n  }, []);\n\n  return [value, handler, setValue];\n};\n\nexport default useInput;\n\n// custom hook\n// 1. Custom Hook은 일반 함수이며, 컴포넌트의 라이프사이클에 직접적으로 연결되지 않습니다.\n// - Custom Hook 내부에서 사용되는 useEffect는 Custom Hook이 호출되는 컴포넌트의 라이프사이클과는 독립적으로 동작합니다.\n// - Custom Hook이 호출될 때마다 해당 useEffect는 실행되고, 그에 따라 특정 작업이 수행됩니다.\n// - Custom Hook을 사용하는 컴포넌트는 이 _Custom Hook이 반환한 값이나 기능을 활용할 수 있지만_\n// - 컴포넌트의 라이프사이클과 Custom Hook 내부의 useEffect는 독립적으로 동작합니다.\n// 2. Custom Hook은 클로저의 개념을 사용하는 것이 일반적입니다.\n// - Custom Hook은 클로저의 원리를 활용하여 호출된 이후의 실행 컨텍스트에 접근할 수 있습니다.\n// - 이를 통해 Custom Hook 내부에서 선언된 변수나 함수가 해당 컴포넌트와 관련된 실행 컨텍스트에서 유지되고 사용될 수 있습니다.\n// 3. Custom Hook은 React 훅의 원리를 활용하여 로직을 추상화하고 재사용 가능하게 만드는 것이 주요 목적입니다.\n// 4. React 컴포넌트는 마운트, 업데이트, 언마운트 등의 라이프사이클 단계에 따라 특정한 동작을 수행할 수 있습니다.\n// - 하지만 Custom Hook은 단순히 함수로 구현되기 때문에 컴포넌트의 라이프사이클과 직접적으로 연결되지 않습니다.\n// - Custom Hook 내에서 useState, useEffect 등의 훅을 사용해도 **해당 훅은 Custom Hook이 호출되는 시점에 실행되며, 컴포넌트의 라이프사이클과 동일한 타이밍으로 실행되지 않습니다.**\n// - 이는 Custom Hook이 여러 컴포넌트에서 재사용될 수 있고, 각 컴포넌트에서 독립적으로 동작할 수 있는 유연성을 제공합니다.\n// - Custom Hook을 사용하는 컴포넌트에서는 Custom Hook 내의 훅을 호출하는 시점과 로직을 조절하여 필요한 동작을 수행할 수 있습니다.\n// - 그렇기 때문에 더 많은 유연성과 재사용성을 가질 수 있습니다.\n// 5. React의 함수형 컴포넌트는 함수 호출 시마다 새로운 실행 컨텍스트가 생성됩니다.\n","import styled from '@emotion/styled';\n\n// 자식 선택자를 많이 이용\n// styled component를 되도록 적게 생성하자 : 변수명 짓기가 어려움\n// e.g. zone, container, wrapper => 공간을 나타내는 단어를 쓰다가 자기가 헷갈림\n\n// styled. 뒤에 태그 이름을 붙여주면 됨\nexport const Header = styled.header`\n  text-align: center;\n  font-family: Slack-Larsseit, Helvetica Neue, Helvetica, Segoe UI, Tahoma, Arial, sans-serif;\n  font-weight: 700; // 글자 굵이\n  font-size: 48px;\n  line-height: 46px;\n  letter-spacing: -0.75px; // 자간\n  margin-top: 50px;\n  margin-bottom: 50px;\n\n  & > img {\n    height: 35px;\n    width: 35px;\n    margin-right: 20px;\n  }\n`;\n\nexport const Form = styled.form`\n  margin: 0 auto;\n  width: 400px;\n  max-width: 400px;\n`;\n\nexport const Label = styled.label`\n  margin-bottom: 16px;\n\n  & > span {\n    display: block;\n    text-align: left;\n    padding-bottom: 8px;\n    font-size: 15px;\n    cursor: pointer;\n    line-height: 1.46666667;\n    font-weight: 700;\n  }\n`;\n\nexport const Input = styled.input`\n  border-radius: 4px;\n  // --saf-0 변수를 사용하여 rgba() 함수를 통해 색상 값을 설정합니다.\n  --saf-0: rgba(var(--sk_foreground_high_solid, 134, 134, 134), 1);\n  border: 1px solid var(--saf-0);\n  // 요소의 상태 변화를 부드럽게 애니메이션화하는 효과를 추가하는데 사용\n  transition: border 80ms ease-out, box-shadow 80ms ease-out;\n  box-sizing: border-box;\n  margin: 0 0 20px;\n  width: 100%;\n  color: rgba(var(--sk_primary_foreground, 29, 28, 29), 1);\n  background-color: rgba(var(--sk_primary_background, 255, 255, 255), 1);\n  padding: 12px;\n  height: 44px;\n  padding-top: 11px;\n  padding-bottom: 13px;\n  font-size: 18px;\n  line-height: 1.33333333;\n\n  &:focus {\n    --saf-0: rgba(var(--sk_highlight, 18, 100, 163), 1);\n    box-shadow: 0 0 0 1px var(--saf-0), 0 0 0 5px rgba(29, 155, 209, 0.3);\n  }\n`;\n\nexport const Button = styled.button`\n  margin-bottom: 12px;\n  width: 100%;\n  max-width: 100%;\n  color: #fff;\n  background-color: #4a154b;\n  border: none;\n  font-size: 18px;\n  font-weight: 900;\n  height: 44px;\n  min-width: 96px;\n  padding: 0 16px 3px;\n  // 요소의 상태 변화를 부드럽게 애니메이션화하는 효과를 추가하는데 사용\n  transition: all 80ms linear;\n  // 요소의 텍스트 내용은 마우스로 드래그하여 선택할 수 없게 됨(일부 브라우저에서만 동작할 수 있음)\n  user-select: none;\n  // 요소에 포커스가 될 때 나타나는 외곽선을 제거하는 역할\n  outline: none;\n  cursor: pointer;\n  border-radius: 4px;\n  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);\n\n  &:hover {\n    background-color: rgba(74, 21, 75, 0.9);\n    border: none;\n  }\n\n  // button이 focus될 때는 클릭되었을 때를 말함\n  &:focus {\n    --saf-0: rgba(var(--sk_highlight, 18, 100, 163), 1);\n    box-shadow: 0 0 0 1px var(--saf-0), 0 0 0 5px rgba(29, 155, 209, 0.3);\n  }\n`;\n\nexport const Error = styled.div`\n  color: #e01e5a;\n  margin: 8px 0 16px;\n  font-weight: bold;\n`;\n\nexport const Success = styled.div`\n  color: #2eb67d;\n  font-weight: bold;\n`;\n\nexport const LinkContainer = styled.p`\n  font-size: 13px;\n  color: #616061;\n  margin: 0 auto 8px;\n  width: 400px;\n  max-width: 400px;\n\n  & a {\n    color: #1264a3;\n    text-decoration: none;\n    font-weight: 700;\n\n    &:hover {\n      text-decoration: underline;\n    }\n  }\n`;\n","import axios from 'axios';\n\n// 결과적으로 return 하는 response.data가 useSWR의 리턴 값으로 return 됨\n\n// 또 하나의 문제\n// withCredentials : 프런트 서버 주소와 백 서버 주소가 다른 경우, cookie 전달이 불가능(브라우저 기본 옵션?)\n// **로그인은 브라우저에 저장된 cookie를 프런트에서 백으로 보내서 확인하는 과정!**\n// 해결 : axios 요청 config 매개 변수 자리에 { withCredentials: true }를 설정\n\n// 로그인은 어느 사이트나 다 cookie에 저장\n// why? cookie가 안전하기 때문\n// 토큰으로 로그인하는 것도 cookie에 저장하는 경우가 있음\nconst fetcher = (url: string) => axios.get(url, { withCredentials: true }).then((response) => response.data);\n\n// get 요청 뿐만 아니라 다른 모든 요청에 적용할 수 있음\n// 다만, 어떤 요청이던 간에 데이터를 fetching하여 swr이 데이터를 저장해주는 기능이다.\n// - 어떤 요청인지가 중요한게 아니라, 데이터를 저장한다는 것이 중요한 것!\nconst fetcherPost = (url: string) => axios.post(url, { withCredentials: true }).then((response) => response.data);\n\n// fetcher는 하나만 사용하지 않고, 여러 개로 다양화해서 사용하자\n// - 서버에서 오는 데이터를 response.data 그대로 저장하지 말자는 뜻!\n// - 대신, 프런트에서 필요한 형태로 swr에 저장\nconst fetcherListLength = (url: string) =>\n  axios.post(url, { withCredentials: true }).then((response) => response.data.length);\n\n// 같은 API 주소에 다른 fetcher를 적용하고 싶은 경우?\n// - API 주소 끝에 #123 과 같은 것 추가 => 서버는 이런 표시를 무시\n\nexport default fetcher;\n"],"names":["initialData","_useState2","useState","value","setValue","useCallback","e","target","Header","_styled","name","styles","Form","Label","Input","Button","Error","Success","LinkContainer","url","axios","withCredentials","then","response","data"],"sourceRoot":""}